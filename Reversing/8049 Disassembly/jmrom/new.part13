2.17 The floating point maths package.

旼컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴커
=RI_SINGL         DO SINGLE MATHS OPERATION PRESERVING A6                     
쳐컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿐NTRY:            D0.W     opcode                                             
                  D7.L     = 0 for reliable operation                         
                  A1.L     relative pointer to top of maths stack             
                  A4.L     relative pointer to base of variables area         
                                                                              
쿐XIT:             A1.L     new pointer to top of maths stack                  
                  D1,D2,D3,A0,A2,A3,A4 preserved                              
                                                                              
쿐RRORS:           ERR.OV   arithmetic overflow                                
읕컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴켸

4228 RI_SINGL      MOVE.L   A6,-(A7)               ;save A6
                   SUBA.L   A6,A6                  ;and set it to zero so that relative values can be used
                   BSR.S    RI_EXEC                ;do the maths operation
                   BRA.S    L04236                 ;and check for any errors

旼컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴커
=RI_LIST          DO LIST OF MATHS OPERATIONS PRESERVING A6                   
쳐컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿐NTRY:            D0.W     opcode                                             
                  D7.L     = 0 for reliable operation                         
                  A1.L     relative pointer to top of maths stack             
                  A3.L     address of list of maths operations                
                  A4.L     relative pointer to base of variables area         
                                                                              
쿐XIT:             A1.L     new pointer to top of maths stack                  
                  D1,D2,D3,A0,A2,A3,A4 preserved                              
                                                                              
쿐RRORS:           ERR.OV   arithmetic overflow                                
읕컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴켸

4230 RI_LIST       MOVE.L   A6,-(A7)               ;save A6
                   SUBA.L   A6,A6                  ;and set it to zero so that relative values can be used
                   BSR.S    RI_EXECB               ;do the list of operations
4236 L04236        BEQ.S    L0423A                 ;jump forward if there were no errors
                   MOVEQ    #0,D2                  ;otherwise signal "error in maths operation"
423A L0423A        MOVEA.L  (A7)+,A6               ;restore saved A6
                   RTS

旼컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴커
=RI_EXEC          DO A MATHS OPERATION                (VECTOR $11C)           
쳐컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿐NTRY:            D0.W     opcode                                             
                  D7.L     = 0 for reliable operation                         
                  A1.L     relative pointer to top of maths stack             
                  A4.L     relative pointer to base of variables area         
                                                                              
쿐XIT:             A1.L     new pointer to top of maths stack                  
                  D1,D2,D3,A0,A2,A3,A4 preserved                              
                                                                              
쿐RRORS:           ERR.OV   arithmetic overflow                                
읕컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴켸

423E RI_EXEC       MOVEM.L  D1-3/A0/A2-3/A5,-(A7)  ;save the normal parameter registers
                   SUBA.L   A5,A5                  ;clear A5 to signal "no maths list"

   This relies on the fact that the first byte in memory (ROM address 0) has
   the value zero which corresponds to the RI.TERM maths operation. 

                   BRA.S    RI_TEST                ;jump forward to do the maths operation

旼컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴커
=RI_EXECB         DO A LIST OF MATHS OPERATIONS       (VECTOR $11E)           
쳐컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿐NTRY:            D0.W     opcode                                             
                  D7.L     = 0 for reliable operation                         
                  A1.L     relative pointer to top of maths stack             
                  A3.L     address of list of maths operations                
                  A4.L     relative pointer to base of variables area         
                                                                              
쿐XIT:             A1.L     new pointer to top of maths stack                  
                  D1,D2,D3,A0,A2,A3,A4 preserved                              
                                                                              
쿐RRORS:           ERR.OV   arithmetic overflow                                
읕컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴켸

4246 RI_EXECB      MOVEM.L  D1-3/A0/A2-3/A5,-(A7)  ;save the normal parameter registers
                   MOVEA.L  A3,A5                  ;and set A5 to address of maths list
424C RI_GET        MOVEQ    #0,D0                  ;clear all of D0
                   MOVE.B   (A5)+,D0               ;get maths operation and exit if it was RI.TERM
                   BEQ.S    RI_EXIT                ;or there was only one maths operation to be done
4252 RI_TEST       CMPI.B   #RI.POWFP,D0           ;normal operation ?
                   BHI.S    RI_LOAD                ;jump forward to do load/store if not
                   BSR.S    RI_JUMP                ;otherwise do the operation
                   BNE.S    RI_EXIT                ;exit if arithmetic overflow occured
                   BRA.S    RI_GET                 ;otherwise get the next operation

   At this point, the value of D0 must have been greater than #30 which signifies
   that a load/store operation is required. Odd values of D0 are used for STORE
   operations which copy a value from the top of the stack to the variables area
   pointed to by the A4 register. Even values are used for LOAD operations which
   copy a value from the variables area to the top of the stack.

425E RI_LOAD       ORI.W    #$FF00,D0              ;make D0.W negative for use as an offset
                   BCLR     #0,D0                  ;and make it even, after testing for odd or even
                   ADDA.W   D0,A4                  ;effectively subtract the offset
                   BNE.S    RI_STORE               ;and jump forward if it was a STORE operation
                   SUBQ.W   #FP.LENGTH,A1          ;make room on the stack for the new number
                   BSR.S    RI_MOVE                ;copy the value from the variables area
                   BRA.S    RI_RESET               ;and check if another operation is required

4270 RI_STORE      EXG      A4,A1                  ;exchange the source and destination pointers
                   BSR.S    RI_MOVE                ;copy the value from the stack
                   EXG      A1,A4                  ;restore the pointers again
                   ADDQ.W   #FP.LENGTH,A1          ;and "remove" the old value from the stack
4278 RI_RESET      SUBA.W   D0,A4                  ;reset the variables area pointer
                   BRA.S    RI_GET                 ;and check if another operation is required

   Copy the floating point number pointed to by the A4 register to the location
   pointed to by the A1 register, exponent first, then mantissa.

427C RI_MOVE       MOVE.W   FP.EXPNT(A6,A4.L),FP.EXPNT(A6,A1.L)
                   MOVE.L   FP.MNTSA(A6,A4.L),FP.MNTSA(A6,A1.L)
                   RTS

428A RI_EXIT       MOVEM.L  (A7)+,D1-3/A0/A2-3/A5  ;restore the normal parameter registers
                   RTS

   Get the offset to the routine to handle the maths operation and jump to it.

4290 RI_JUMP       MOVE.W   MATHTBL - RI.NINT(PC,D0.W),D0
                   JMP      MATHTBL(PC,D0.W)

   Table of offsets for the maths operations.

4298 MATHTBL       DC.W     RI_NINT - MATHTBL      ;integer floating point into word integer
                   DC.W     RI_INT  - MATHTBL      ;truncate floating point into word integer
                   DC.W     RI_NLINT- MATHTBL      ;integer floating point into long word integer
                   DC.W     RI_LINT - MATHTBL      ;convert integer word into floating point form
                   DC.W     RI_ADD  - MATHTBL      ;add TOS to NOS
                   DC.W     RI_SUB  - MATHTBL      ;subtract TOS from NOS
                   DC.W     RI_MULT - MATHTBL      ;multiply TOS by NOS
                   DC.W     RI_DIV  - MATHTBL      ;divide TOS into NOS
                   DC.W     RI_ABS  - MATHTBL      ;take positive value
                   DC.W     RI_NEG  - MATHTBL      ;negate TOS
                   DC.W     RI_DUP  - MATHTBL      ;duplicate TOS
                   DC.W     RI_COS  - MATHTBL      ;cosine of TOS
                   DC.W     RI_SIN  - MATHTBL      ;sin of TOS
                   DC.W     RI_TAN  - MATHTBL      ;tangent of TOS
                   DC.W     RI_COT  - MATHTBL      ;cotangent of TOS
                   DC.W     RI_ASIN - MATHTBL      ;arcsine of TOS
                   DC.W     RI_ACOS - MATHTBL      ;arccosine of TOS
                   DC.W     RI_ATAN - MATHTBL      ;arctangent of TOS
                   DC.W     RI_ACOT - MATHTBL      ;arccotangent of TOS
                   DC.W     RI_SQRT - MATHTBL      ;square root of TOS
                   DC.W     RI_LN   - MATHTBL      ;natural logarithm of TOS (to base e)
                   DC.W     RI_LOG10- MATHTBL      ;common logarithm of TOS (to base 10)
                   DC.W     RI_EXP  - MATHTBL      ;exponential of TOS (to power e)
                   DC.W     RI_POWFP- MATHTBL      ;raise NOS to power of TOS

旼컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴커
=RI_SIN           SIN OF TOS                                                  
쳐컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿝ANGE:            -10,000 .. +10,000 radians                                  
                                                                              
쿐NTRY:            D7.L     should be 0 for reliability                        
                  A1.L     relative pointer to top of maths stack             
                                                                              
쿐XIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          
                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       
                                                                              
쿐RRORS:           ERR.OV   arithmetic overflow                                
읕컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴켸

42C8 RI_SIN        MOVEM.L  D4-7/A4,-(A7)          ;save the remaining registers
                   MOVEQ    #0,D7                  ;signal "sin required"
                   BRA.S    RI_TRIG                ;compute the sin

旼컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴커
=RI_COS           COSINE OF TOS                                               
쳐컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿝ANGE:            -10,000 .. +10,000 radians                                  
                                                                              
쿐NTRY:            D7.L     should be 0 for reliability                        
                  A1.L     relative pointer to top of maths stack             
                                                                              
쿐XIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          
                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       
                                                                              
쿐RRORS:           ERR.OV   arithmetic overflow                                
읕컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴켸

   Cos(A) is equal to Cos(-A).

42D0 RI_COS        MOVEM.L  D4-7/A4,-(A7)          ;save the remaining registers
                   JSR      RI_ABS(PC)             ;take the absolute value to form Cos(쿻)
                   MOVEQ    #-1,D7                 ;and signal "cos required"
42DA RI_TRIG       JSR      L0471A(PC)
                   BNE.S    L04342
                   BSR.S    L04348
                   LEA      L04644(PC),A4
                   BSR.S    L0435A
                   BTST     #0,D7
                   BEQ.S    L04342
                   JSR      RI_NEG(PC)
                   BRA.S    L04342

旼컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴커
=RI_TAN           TANGENT OF TOS                                              
쳐컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿝ANGE:            -30,000 .. +30,000 radians                                  
                                                                              
쿐NTRY:            D7.L     should be 0 for reliability                        
                  A1.L     relative pointer to top of maths stack             
                                                                              
쿐XIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          
                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       
                                                                              
쿐RRORS:           ERR.OV   arithmetic overflow                                
읕컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴켸

42F4 RI_TAN        MOVEM.L  D4-7/A4,-(A7)          ;save the remaining registers
                   MOVEQ    #0,D6
                   BRA.S    L04306

旼컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴커
=RI_COT           COTANGENT OF TOS                                            
쳐컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿝ANGE:            -30,000 .. +30,000 radians                                  
                                                                              
쿐NTRY:            D7.L     should be 0 for reliability                        
                  A1.L     relative pointer to top of maths stack             
                                                                              
쿐XIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          
                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       
                                                                              
쿐RRORS:           ERR.OV   arithmetic overflow                                
읕컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴켸

42FC RI_COT        MOVEM.L  D4-7/A4,-(A7)          ;save the remaining registers
                   MOVEQ    #-1,D6
                   JSR      RI_NEG(PC)
4306 L04306        MOVEQ    #0,D7
                   JSR      L0470A(PC)
                   BNE.S    L04342
                   EOR.B    D6,D7
                   BSR.S    L04348
                   LEA      L0466C(PC),A4
                   JSR      L047C0(PC)
                   ADDQ.W   #FP.LENGTH,A1
                   BSR.S    L0435E
                   SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   MOVE.L   -2*FP.LENGTH+FP.MNTSA(A6,A1.L),FP.MNTSA(A6,A1.L)
                   MOVE.W   -2*FP.LENGTH+FP.EXPNT(A6,A1.L),FP.EXPNT(A6,A1.L)
                   BTST     #0,D7
                   BEQ.S    L0433C
                   JSR      L04AE0(PC)
                   JSR      RI_NEG
433C L0433C        JSR      RI_DIV(PC)
4340 L04340        MOVEQ    #0,D0
4342 L04342        MOVEM.L  (A7)+,D4-7/A4          ;partially restore the registers
                   RTS

4348 L04348        JSR      RI_DUP(PC)
434C L0434C        JSR      RI_DUP(PC)
                   JSR      RI_DUP(PC)
                   JSR      RI_MULT(PC)
                   RTS

435A L0435A        JSR      L047C6(PC)
435E L0435E        JSR      RI_MULT(PC)
                   JSR      RI_ADD(PC)
                   RTS

4368 L04368        SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   CLR.W    4(A6,A1.L)
                   MOVE.L   #$08014000,FP.EXPNT(A6,A1.L)
                   JSR      L04AE0(PC)
                   RTS

旼컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴커
=RI_ACOS          ARCCOSINE OF TOS                                            
쳐컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿝ANGE:                                                                        
                                                                              
쿐NTRY:            D7.L     should be 0 for reliability                        
                  A1.L     relative pointer to top of maths stack             
                                                                              
쿐XIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          
                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       
                                                                              
쿐RRORS:           ERR.OV   arithmetic overflow                                
읕컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴켸

437C RI_ACOS       JSR      RI_NEG(PC)
                   BSR.S    RI_ASIN
                   BNE.S    L043B4
                   BSR.S    L043A4
                   JMP      RI_ADD(PC)

旼컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴커
=RI_ASIN          ARCSIN OF TOS                                               
쳐컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿝ANGE:                                                                        
                                                                              
쿐NTRY:            D7.L     should be 0 for reliability                        
                  A1.L     relative pointer to top of maths stack             
                                                                              
쿐XIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          
                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       
                                                                              
쿐RRORS:           ERR.OV   arithmetic overflow                                
읕컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴켸

438A RI_ASIN       BSR.S    L0434C
                   BSR.S    L04368
                   JSR      RI_SUB(PC)
                   BSR      RI_SQRT
                   BNE.S    L043B4
                   JSR      RI_DIV(PC)
                   BEQ.S    RI_ATAN
                   BSR.S    L043A4
                   JMP      RI_MULT(PC)

43A4 L043A4        SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   MOVE.L   #$6487ED51,FP.MNTSA(A6,A1.L)
                   MOVE.W   #$0801,FP.EXPNT(A6,A1.L)
43B4 L043B4        RTS

旼컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴커
=RI_ACOT          ARCCOTANGENT OF TOS                                         
쳐컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿝ANGE:                                                                        
                                                                              
쿐NTRY:            D7.L     should be 0 for reliability                        
                  A1.L     relative pointer to top of maths stack             
                                                                              
쿐XIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          
                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       
                                                                              
쿐RRORS:           ERR.OV   arithmetic overflow                                
읕컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴켸

43B6 RI_ACOT       MOVEM.L  D4-7/A4,-(A7)          ;save the remaining registers
                   MOVEQ    #2,D7
                   BRA.S    L043C4

旼컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴커
=RI_ATAN          ARCTANGENT OF TOS                                           
쳐컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿝ANGE:                                                                        
                                                                              
쿐NTRY:            D7.L     should be 0 for reliability                        
                  A1.L     relative pointer to top of maths stack             
                                                                              
쿐XIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          
                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       
                                                                              
쿐RRORS:           ERR.OV   arithmetic overflow                                
읕컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴켸

43BE RI_ATAN       MOVEM.L  D4-7/A4,-(A7)          ;save the remaining registers
                   MOVEQ    #0,D7
43C4 L043C4        TST.B    FP.MNTSA(A6,A1.L)
                   BGE.S    L043D0
                   ADDQ.B   #4,D7
                   JSR      RI_NEG(PC)
43D0 L043D0        CMPI.W   #$0800,FP.EXPNT(A6,A1.L)
                   BLE.S    L043E2
                   BSR.S    L04368
                   JSR      RI_DIV(PC)
                   BCHG     #1,D7
43E2 L043E2        JSR      RI_DUP(PC)
                   SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   MOVE.L   #$4498517A,FP.MNTSA(A6,A1.W)
                   MOVE.W   #$07FF,FP.EXPNT(A6,A1.L)
                   JSR      RI_SUB(PC)
                   ADDQ.W   #FP.LENGTH,A1
                   TST.B    -FP.LENGTH+FP.MNTSA(A6,A1.L)
                   BLE.S    L04410
                   LEA      L04688(PC),A4
                   JSR      L047C0(PC)
                   JSR      RI_DIV(PC)
                   ADDQ.B   #1,D7
4410 L04410        BSR      L04348
                   LEA      L046B0(PC),A4
                   JSR      L047C0(PC)
                   JSR      RI_DIV(PC)
                   BSR      L0435E
                   LSR.B    #1,D7
                   BCC.S    L0443C
                   SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   MOVE.L   #$430548E1,FP.MNTSA(A6,A1.L)
                   MOVE.W   #$0800,FP.EXPNT(A6,A1.L)
                   JSR      RI_ADD(PC)
443C L0443C        LSR.B    #1,D7
                   BCC.S    L0444C
                   JSR      RI_NEG(PC)
                   BSR      L043A4
                   JSR      RI_ADD(PC)
444C L0444C        LSR.B    #1,D7
                   BCC      L04340
                   JSR      RI_NEG(PC)
                   BRA      L04342

445A L0445A        MOVE.W   FP.EXPNT(A6,A1.L),D1
                   BEQ.S    L0447E
                   MOVE.W   #$080F,D0
                   SUB.W    D1,D0
                   BLT.S    L04488
                   CMPI.W   #15,D0
                   BGT.S    L04488
                   MOVE.L   FP.MNTSA(A6,A1.L),D1
                   TST.W    D1
                   BNE.S    L04488
                   ASR.L    D0,D1
                   TST.W    D1

旼컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴커
=RI_POWFP         TOS RAISED TO POWER OF NOS                                  
쳐컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿝ANGE:                                                                        
                                                                              
쿐NTRY:            D7.L     should be 0 for reliability                        
                  A1.L     relative pointer to top of maths stack             
                                                                              
쿐XIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          
                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       
                                                                              
쿐RRORS:           ERR.OV   arithmetic overflow                                
읕컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴켸

447A RI_POWFP      BNE.S    L04488
                   SWAP     D1
447E L0447E        ADDQ.W   #4,A1
                   MOVE.W   D1,FP.EXPNT(A6,A1.L)
                   JMP      L04876(PC)

4488 L04488        MOVEM.L  D4-7/A4,-(A7)          ;save the remaining registers
                   MOVE.W   FP.EXPNT(A6,A1.L),D4
                   MOVE.L   FP.MNTSA(A6,A1.L),D5
                   ADDQ.W   #FP.LENGTH,A1
                   TST.B    FP.MNTSA(A6,A1.L)
                   BEQ.S    L044B8
                   BSR.S    RI_LN
                   BNE      L04342
                   SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   MOVE.L   D5,FP.MNTSA(A6,A1.L)
                   MOVE.W   D4,FP.EXPNT(A6,A1.L)
                   JSR      RI_MULT(PC)
                   BNE      L04342
                   BRA      L0457A

44B8 L044B8        TST.B    -FP.LENGTH+FP.MNTSA(6,A1.L)
                   BGE      L04340
                   BRA      ERR_OV_1

旼컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴커
=RI_LOG10         COMMON LOGARITHM OF TOS                                     
쳐컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿝ANGE:                                                                        
                                                                              
쿐NTRY:            D7.L     should be 0 for reliability                        
                  A1.L     relative pointer to top of maths stack             
                                                                              
쿐XIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          
                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       
                                                                              
쿐RRORS:           ERR.OV   arithmetic overflow                                
읕컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴켸

44C4 RI_LOG10      BSR.S    RI_LN
                   BNE.S    L044DC
                   SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   MOVE.L   #$6F2DEC55,FP.MNTSA(A6,A1.L)
                   MOVE.W   #$07FF,FP.EXPNT(A6,A1.L)
                   JSR      RI_MULT(PC)
44DC L044DC        RTS

旼컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴커
=RI_LN            NATURAL LOGARITHM OF TOS                                    
쳐컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿝ANGE:                                                                        
                                                                              
쿐NTRY:            D7.L     should be 0 for reliability                        
                  A1.L     relative pointer to top of maths stack             
                                                                              
쿐XIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          
                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       
                                                                              
쿐RRORS:           ERR.OV   arithmetic overflow                                
읕컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴켸

44DE RI_LN         MOVEM.L  D4-7/A4,-(A7)          ;save the remaining registers
                   MOVE.W   FP.EXPNT(A6,A1.L),D4
                   MOVE.L   FP.MNTSA(A6,A1.L),D5
                   ADDQ.W   #FP.LENGTH,A1
                   BLE      ERR_OV_1
                   MOVE.W   #$0800,D0
                   MOVE.L   D5,D1
                   LSR.L    #1,D5
                   CMPI.L   #$5A82799A,D1
                   BGT.S    L0450E
                   SUBQ.W   #1,D4
                   ADDI.L   #$20000000,D5
                   BCLR     #30,D1
                   BRA.S    L04516

450E L0450E        BSET     #30,D5
                   BSET     #31,D1
4516 L04516        TST.L    D1
                   JSR      L048CC(PC)
                   SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   MOVE.L   D5,FP.MNTSA(A6,A1.L)
                   MOVE.W   #$0800,FP.EXPNT(A6,A1.L)
                   JSR      RI_DIV(PC)
                   BSR      L04348
                   JSR      RI_DUP(PC)
                   LEA      L046CC(PC),A4
                   MOVE.W   D4,D7
                   JSR      L047C0(PC)
                   JSR      RI_DIV(PC)
                   JSR      RI_MULT(PC)
                   BSR      L0435E
                   SUBI.W   #$0800,D7
                   SUBQ.W   #2,A1
                   MOVE.W   D7,FP.EXPNT(A6,A1.L)
                   JSR      RI_LINT(PC)
                   SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   MOVE.L   #$58B90BFC,FP.MNTSA(A6,A1.L)
                   MOVE.W   #$0800,FP.EXPNT(A6,A1.L)
                   BSR      L0435E
                   BRA      L04340

4570 ERR_OV_1      MOVEQ    #ERR_OV,D0             ;signal "arithmetic overflow"
4572 L04572        BRA      L04342

旼컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴커
=RI_EXP           EXPONENTIAL OF TOS                                          
쳐컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿝ANGE:            -500 .. +500                                                
                                                                              
쿐NTRY:            D7.L     should be 0 for reliability                        
                  A1.L     relative pointer to top of maths stack             
                                                                              
쿐XIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          
                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       
                                                                              
쿐RRORS:           ERR.OV   arithmetic overflow                                
읕컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴켸

4576 RI_EXP        MOVEM.L  D4-7/A4,-(A7)          ;save the remaining registers
457A L0457A        JSR      L04728(PC)
                   BNE.S    L04572
                   BSR      L0434C
                   LEA      L046EE(PC),A4
                   JSR      L047C0(PC)
                   ADDQ.W   #FP.LENGTH,A1
                   JSR      RI_MULT(PC)
                   JSR      RI_DUP(PC)
                   SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   JSR      L04AE0(PC)
                   JSR      RI_SUB(PC)
                   JSR      RI_DIV(PC)
                   SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   MOVE.L   #$40000000,FP.MNTSA(A6,A1.L)
                   MOVE.W   #$0800,FP.EXPNT(A6,A1.L)
                   JSR      RI_ADD(PC)
                   ADDQ.W   #1,D7
                   ADD.W    D7,FP.EXPNT(A6,A1.L)
                   BRA      L04340

旼컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴커
=RI_SQRT          SQUARE ROOT OF TOS                                          
쳐컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿝ANGE:                                                                        
                                                                              
쿐NTRY:            D7.L     should be 0 for reliability                        
                  A1.L     relative pointer to top of maths stack             
                                                                              
쿐XIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          
                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       
                                                                              
쿐RRORS:           ERR.OV   arithmetic overflow                                
읕컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴켸

45C2 RI_SQRT       MOVEM.L  D4-7/A4,-(A7)          ;save the remaining registers
                   MOVE.W   FP.EXPNT(A6,A1.L),D6
                   TST.L    FP.MNTSA(A6,A1.L)
                   BEQ      L04340
                   BLT.S    ERR_OV_1
                   LEA      L046FC(PC),A4
                   MOVE.W   D6,D7
                   SUBI.W   #$0800,D7
                   SUB.W    D7,FP.EXPNT(A6,A1.L)
                   ASR.W    #1,D7
                   BCC.S    L045EA
                   LEA      L0470A(PC),A4
45EA L045EA        SWAP     D6
                   JSR      L047C6(PC)
                   SWAP     D6
                   ADD.W    D7,FP.EXPNT(A6,A1.L)
                   MOVEQ    #1,D7
45F8 L045F8        JSR      RI_DUP(PC)
                   SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   MOVE.L   D5,FP.MNTSA(A6,A1.L)
                   MOVE.W   D6,FP.EXPNT(A6,A1.L)
                   JSR      L04AE0(PC)
                   JSR      RI_DIV(PC)
                   JSR      RI_ADD(PC)
                   SUBQ.W   #1,FP.EXPNT(A6,A1.L)
                   DBF      D7,L045F8
                   BRA      L04340

                   DC.W    $0000,$0000,$0000       ; 0
                   DC.W    $07FE,$AAAA,$AAB0       ; -1.666667 x 10 -1
                   DC.W    $07FA,$4444,$42DD       ; +8.333333 x 10 -3
                   DC.W    $07F4,$97FA,$15C1       ; -1.984083 x 10 -4
                   DC.W    $07EE,$5C5A,$E940       ; +2.752397 x 10 -6
                   DC.W    $07E7,$997C,$79C0       ; -2.386835 x 10 -8
4642 L04642        DC.W    5

                   DC.W    $0801,$4000,$0000       ; +1
                   DC.W    $07FF,$8E28,$7BC1       ; -4.446948 x 10 -1
                   DC.W    $07FB,$416D,$50CD       ; +1.597339 x 10 -2
4656 L04656        DC.W    2

                   DC.W    $0000,$0000,$0000       ; 0
                   DC.W    $07FD,$8DF7,$443E       ; -1.113614 x 10 -1
                   DC.W    $07F7,$4676,$1A70       ; +1.075155 x 10 -3
466A L0466A        DC.W    2

                   DC.W    $0801,$6ED9,$EBA1       ; +1.732051
                   DC.W    $0801,$4000,$0000       ; +1
4678 L04678        DC.W    1

                   DC.W    $0800,$8000,$0000       ; -1
                   DC.W    $0801,$6ED9,$EBA1       ; +1.732051
4686 L04686        DC.W    1

                   DC.W    $0803,$451F,$BEDF       ; +4.320250
                   DC.W    $0803,$4C09,$1DF8       ; +4.752226
                   DC.W    $0801,$4000,$0000       ; +1
469A L0469A        DC.W    2

                   DC.W    $0000,$0000,$0000       ; 0
                   DC.W    $0801,$A3D5,$AC3B       ; -1.440083
                   DC.W    $0800,$A3D6,$2904       ; -7.200268 x 10 -1
46AE L046AE        DC.W    2

                   DC.W    $0803,$A6BC,$EEE1       ; -5.578874
                   DC.W    $0801,$4000,$0000       ; +1
46BC L046BC        DC.W    1

                   DC.W    $07FF,$88FB,$E7C1       ; -4.649062 x 10 -1
                   DC.W    $07FA,$6F6B,$44F3       ; +1.360095
46CA L046CA        DC.W    1

                   DC.W    $0800,$4000,$0000       ; +1
                   DC.W    $07FC,$6DB4,$CE83       ; +5.356752 x 10 -2
                   DC.W    $07F5,$4DEF,$09CA       ; +2.972936 x 10 -4
46DE L046DE        DC.W    2

                   DC.W    $07FF,$4000,$0000       ; +2.500000 x 10 -1
                   DC.W    $07F9,$617D,$E4BA       ; +5.950425 x 10 -3
46EC L046EC        DC.W    1

                   DC.W    $07FF,$6AD4,$D402       ; +4.173100 x 10 -1
                   DC.W    $0800,$4B8A,$5CE6       ; +5.901600 x 10 -1
46FA L046FA        DC.W    1

                   DC.W    $0800,$4B8A,$5CE6       ; +5.901600 x 10 -1
                   DC.W    $0800,$6AD4,$D402       ; +4.173100 x 10 -1
4708 L04708        DC.W    1

470A L0470A        ADDQ.W  #1,0(A6,A1.L)
                   BSR.S   L0471A
                   BNE.S   L04786
                   SUBQ.W  #1,0(A6,A1.L)
                   MOVEQ   #0,D0
                   RTS

471A L0471A        LEA      L047AE(PC),A4
                   CMPI.W   #$0810,FP.EXPNT(A6,A1.L)
                   BGT.S    ERR_OV_2
                   BRA.S    L04734

4728 L04728        LEA      L047C0(PC),A4
                   CMPI.W   #$0809,FP.EXPNT(A6,A1.L)
                   BGT.S    ERR_OV_2
4734 L04734        JSR      RI_DUP(PC)             ; x,x
                   SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number

   Copy the floating point co-efficient pointed to by the A4 register to the top
   of the maths stack.

                   MOVE.L   -(A4),FP.MNTSA(A6,A1.L)
                   MOVE.W   -(A4),FP.EXPNT(A6,A1.L)
                   JSR      RI_MULT(PC)            ; x,ax
                   TST.B    D7                     ; "sin" or "cos" ?
                   BNE.S    L04756                 ;jump forward if "cos"
                   JSR      RI_NINT(PC)            ;convert to an integer
                   MOVE.W   D1,D7                  ;
                   JSR      RI_LINT(PC)
                   BRA.S    L0476C

4756 L04756        JSR      RI_INT(PC)
                   ADD.W    D1,D7
                   ADD.W    D1,FP.EXPNT(A6,A1.L)
                   ADDQ.W   #1,FP.EXPNT(A6,A1.L)
                   JSR      RI_LINT(PC)
                   SUBQ.W   #1,FP.EXPNT(A6,A1.L)
476C L0476C        MOVE.W   FP.EXPNT(A6,A1.L),D4
                   MOVE.L   FP.MNTSA(A6,A1.L),D5
                   BSR.S    L04788
                   SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   MOVE.L   D5,FP.MNTSA(A6,A1.L)
                   MOVE.W   D4,FP.EXPNT(A6,A1.L)
                   BSR.S    L04788
                   RTS

4784 ERR_OV_2      MOVEQ    #ERR_OV,D0             ;signal "arithmetic overflow"
                   RTS

4788 L04788        SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   MOVE.L   -(A4),FP.MNTSA(A6,A1.L)
                   MOVE.W   -(A4),FP.EXPNT(A6,A1.L)
                   JSR      RI_MULT(PC)
                   JSR      RI_SUB(PC)
                   RTS

479C L0479C        DC.W     $07F0,$B544,$42D1      ; -8.908910 x 10 -6
                   DC.W     $0802,$6488,$0000      ; +3.141602
                   DC.W     $07FF,$517C,$C1B7      ; +3.183099 x 10 -1
                   DC.W     $07F4,$90BF,$BE8F      ; -2.121944 x 10 -4
                   DC.W     $0800,$58C0,$0000      ; +6.933594 x 10 -1
                   DC.W     $0801,$5C55,$1D95      ; +1.442695

47C0 L047C0        BSR.S    L047C6
                   SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   BRA.S    L047CE

47C6 L047C6        MOVE.W   FP.EXPNT(A6,A1.L),D4
                   MOVE.L   FP.MNTSA(A6,A1.L),D5
47CE L047CE        MOVE.W   -(A4),D6
                   MOVE.L   -(A4),FP.MNTSA(A6,A1.L)
                   MOVE.W   -(A4),FP.EXPNT(A6,A1.L)
47D8 L047D8        SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   MOVE.L   D5,FP.MNTSA(A6,A1.L)
                   MOVE.W   D4,FP.EXPNT(A6,A1.L)
                   JSR      RI_MULT(PC)
                   SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   MOVE.L   -(A4),FP.MNTSA(A6,A1.L)
                   MOVE.W   -(A4),FP.EXPNT(A6,A1.L)
                   JSR      RI_ADD(PC)
                   SUBQ.W   #1,D6
                   BGT.S    L047D8
                   RTS

旼컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴커
=RI_TRUNC         TRUNCATE FLOATING POINT FORM INTO LONG WORD INTEGER         
=RI_NORND         AS ABOVE WITH NO ROUNDING PRIOR TO TRUNCATION               
쳐컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿐NTRY:            D7.L     should be 0 for reliability                        
                  A1.L     relative pointer to top of maths stack             
                                                                              
쿐XIT:             D0.L     amount of truncation in bits                       
                  D1.L     truncated TOS                                      
                  D2,D3,A0,A2 and A3 corrupted                                
                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       
                                                                              
쿐RRORS:           ERR.OV   arithmetic overflow                                
읕컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴켸

47FA RI_TRUNC      SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   CLR.W    4(A6,A1.L)             ;and set it to 0.5
                   MOVE.L   #$08004000,0(A6,A1.L)
                   JSR      RI_ADD(PC)             ;round TOS up to nearest integer
480C RI_NORND      MOVE.W   FP.EXPNT(A6,A1.L),D0
                   MOVE.L   FP.MNTSA(A6,A1.L),D1
                   ADDQ.W   #2,A1                  ;re-adjust stack pointer for a long word
                   CLR.L    FP.EXPNT(A6,A1.L)      ;and set it to zero

   Subtracting $0800 from the exponent will give the power of two of the
   mantissa. If this is greater than zero then this means that the absolute
   value of the number represented is greater than 1. If it is less than zero
   then the number represented is fractional.

                   SUBI.W   #$0800,D0              ;number greater than or less than one ?
                   BGE.S    L04822                 ;and jump forward if greater than or equal to 1
                   MOVEQ    #0,D0                  ;if less than one then just use one
4822 L04822        SUBI.W   #31,D0                 ;find amount of actual shift from power of two
                   NEG.W    D0                     ;and negate it as we're moving right
                   ASR.L    D0,D1                  ;do shift right (left if D0 is negative)
                   MOVE.L   D1,FP.EXPNT(A6,A1.L)   ;and copy result to the top of the stack
                   RTS

旼컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴커
=RI_NINT          INTEGER FLOATING POINT FORM INTO WORD INTEGER               
=RI_INT           TRUNCATE FLOATING POINT FORM INTO WORD INTEGER              
=RI_NLINT         INTEGER FLOATING POINT FORM INTO LONG INTEGER               
=RI_LINT          CONVERT INTEGER WORD INTO FLOATING POINT FORM               
쳐컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿝ANGE:                                                                        
                                                                              
쿐NTRY:            D7.L     should be 0 for reliability                        
                  A1.L     relative pointer to top of maths stack             
                                                                              
쿐XIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          
                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       
                                                                              
쿐RRORS:           ERR.OV   arithmetic overflow                                
읕컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴켸

4830 RI_NINT       BSR.S    RI_TRUNC               ;get long word equivalent of TOS after rounding up
                   BRA.S    L04836                 ;and convert it if possible to a word

4834 RI_INT        BSR.S    RI_NORND               ;as above but with no rounding during the conversion
4836 L04836        ADDQ.L   #2,A1                  ;re-adjust stack pointer for a word
                   CMPI.W   #16,D0                 ;number greater than 65536 ?
                   BLT.S    ERR_OV_3               ;exit if so as the conversion cannot be made
                   BRA.S    L0484A                 ;otherwise exit normally

4840 RI_NLINT      BSR.S    RI_TRUNC               ;get long word equivalent of TOS after rounding up
                   BRA.S    L04846                 ;check for truncation

4844 L04844        BSR.S    RI_NORND               ;as above but with no rounding during the conversion
4846 L04846        TST.W    D0                     ;was the origonal number truncated to fit ?
                   BLT.S    ERR_OV_3               ;exit with error if so
484A L0484A        MOVEQ    #0,D0                  ;otherwise signal "no errors"
                   RTS

484E ERR_OV_3      MOVEQ    #ERR.OV,D0             ;signal "arithmetic overflow"
                   RTS

4852 RI_LINT       MOVE.W   #$081F,D0
                   MOVE.W   FP.EXPNT(A6,A1.L),D1
                   ADDQ.W   #2,A1
                   EXT.L    D1
                   JMP      L048CC(PC)

4862 L04862        SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   CLR.W    $04(A6,A1.L)
                   MOVE.L   #$08014000,0(A6,A1.L)
                   JSR      L04AE0(PC)
                   RTS

4876 L04876        MOVEM.L  D4-6,-(A7)             ;save the remaining registers
                   MOVE.W   FP.EXPNT(A6,A1.L),D6
                   ADDQ.W   #2,A1
                   BGE.S    L0488C
                   NEG.W    D6
                   BSR.S    L04862
                   JSR      RI_DIV(PC)
                   BNE.S    L048BE
488C L0488C        BSR.S    L04862
488E L0488E        LSR.W    #1,D6
                   BCC.S    L048AA
                   MOVE.W   FP.EXPNT(A6,A1.L),D5
                   MOVE.L   FP.MNTSA(A6,A1.L),D4
                   JSR      RI_MULT(PC)
                   SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   BNE.S    L048BC
                   MOVE.L   D4,FP.MNTSA(A6,A1.L)
                   MOVE.W   D5,FP.EXPNT(A6,A1.L)
48AA L048AA        TST.W    D6
                   BEQ.S    L048BA
                   JSR      RI_DUP(PC)
                   JSR      RI_MULT(PC)
                   BNE.S    L048BC
                   BRA.S    L0488E

48BA L048BA        MOVEQ    #0,D0
48BC L048BC        ADDQ.W   #FP.LENGTH,A1
48BE L048BE        MOVEM.L  (A7)+,D4-6
                   RTS

旼컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴커
=RI_SUB           SUBTRACT TOS FROM NOS                                       
=RI_ADD           ADD TOS TO NOS                                              
쳐컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿝ANGE:                                                                        
                                                                              
쿐NTRY:            D7.L     should be 0 for reliability                        
                  A1.L     relative pointer to top of maths stack             
                                                                              
쿐XIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          
                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       
                                                                              
쿐RRORS:           ERR.OV   arithmetic overflow                                
읕컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴켸

   On entry the maths stack should contain two floating point numbers as shown
   below:-

        쳐컴컴컴컴컴컴캑
          subtrahend   NOS
        쳐컴컴컴컴컴컴캑
          subtractor   TOS
   A1 ->쳐컴컴컴컴컴컴캑

   where the subtrahend is the number being subtracted from and the subtractor
   is what is being subtracted. The difference is left on the top of the stack.


48C4 RI_SUB        JSR      RI_NEG(PC)             ;negate TOS first then
                   JMP      RI_ADD(PC)             ;add it to the NOS

48CC L048CC        SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number
                   TST.L    D1
                   BRA.S    L0490A

   On entry the maths stack should contain two floating point numbers as shown
   below:-

        쳐컴컴컴컴컴컴캑
            addend     NOS
        쳐컴컴컴컴컴컴캑
            adder      TOS
   A1 ->쳐컴컴컴컴컴컴캑

   where the addend is the number being added to and the adder is what is being
   added. The sum is left on the top of the stack. The addition can only be
   performed when the exponents of the two numbers are the same so one of them
   will be readjusted to have the same expoent as the other.

48D2 RI_ADD        ADDQ.W   #FP.LENGTH,A1          ;point A1 at the addend
                   MOVE.W   FP.EXPNT(A6,A1.L),D0   ;get exponent of addend

   conmpare the two exponents of the two numbers and find which is the lesser
   then normalise this to have the same expoent as the other.

                   SUB.W    -FP.LENGTH+FP.EXPNT(A6,A1.L),D0
                   BGE.S    L048F6                 ;jump forward if addend greater than adder

   the addend was less than the adder so check the addend to see how much less
   it actually is.

                   NEG.W    D0                     ;negate difference as this is less than zero
                   CMPI.W   #32,D0                 ;is the adder very much greater than the addend ?
                   BGE.S    L0493E                 ;then exit with the adder as the sum if so
                   MOVE.L   FP.MNTSA(A6,A1.L),D1   ;otherwise get mantissa for addend from adder and
                   BSR.S    L04952                 ;adjust the addend

   copy the exponent into the result and add the mantissas then check the result
   for arithmetic overflow.

                   MOVE.W   -FP.LENGTH+FP.EXPNT(6,A1.L),D0
                   ADD.L    -FP.LENGTH+FP.MNTSA(6,A1.L),D1
                   BRA.S    L0490A

   the addend was greater than the adder so again check by how much.

48F6 L048F6        CMPI.W   #32,D0                 ;is the addend very much greater than the adder ?
                   BGE.S    L0494E                 ;then exit with the addend as the sum if so

   get the mantissa for the adder from addend and adjust the adder.

                   MOVE.L   -FP.LENGTH+FP.MNTSA(6,A1.L),D1
                   BSR.S    L04952

   copy the exponent into the result and add the mantissas then check the result
   for arithmetic overflow.

                   MOVE.W   FP.EXPNT(A6,A1.L),D0
                   ADD.L    FP.MNTSA(A6,A1.L),D1
490A L0490A        BVS.S    L04928                 ;jump forward if overflow occured

   if the answer is zero then use the correct floating point representation for
   zero.

                   BEQ.S    L0493A                 ;form floating point zero
                   MOVE.L   D1,D3
                   ADD.L    D3,D3
                   BVS.S    L04946
                   MOVEQ    #$10,D2
4916 L04916        MOVE.L   D1,D3
                   ASL.L    D2,D3
                   BVS.S    L04922
                   MOVE.L   D3,D1
                   SUB.W    D2,D0
                   BLT.S    L04936
4922 L04922        ASR.L    #1,D2
                   BNE.S    L04916
                   BRA.S    L04946

4928 L04928        ROXR.L   #1,D1                  ;shift mantissa down 
                   ADDQ.W   #1,D0                  ;and increment exponent correspondingly
                   BTST     #12,D0                 ;overflow of exponent ?
                   BEQ.S    L04946                 ;exit if not otherwise
                   MOVEQ    #ERR_OV,D0             ;signal "arithmetic overflow"
                   RTS

4936 L04936        NEG.W    D0
                   ASR.L    D0,D1
493A L0493A        CLR.W    D0                     ;clear the exponent, the mantissa is already zero
                   BRA.S    L04946                 ;and store the result

   get the adder as the result prior to storing.

493E L0493E        MOVE.W   -FP.LENGTH+FP.EXPNT(6,A1.L),D0
                   MOVE.L   -FP.LENGTH+FP.MNTSA(6,A1.L),D1

   store the result into the new top of the stack exponent first then mantissa.

4946 L04946        MOVE.L   D1,FP.MNTSA(A6,A1.L)
                   MOVE.W   D0,FP.EXPNT(A6,A1.L)
494E L0494E        MOVEQ    #0,D0                  ;signal "no errors"
                   RTS

4952 L04952        TST.W    D0                     ;amount of normalisation zero ?
                   BEQ.S    L04964                 ;exit if so
                   ASR.L    D0,D1                  ;normalise mantissa by shifting down

   each downwards shift will result in the loss of accuraccy.

                   BCC.S    L04964                 ;exit if no carry 
                   ADDQ.L   #1,D1                  ;otherwise round up
                   SUBQ.W   #1,D0                  ;
                   BGT.S    L04964
                   BCLR     #0,D1
4964 L04964        RTS

旼컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴커
=RI_MULT          MULTIPLY NOS BY TOS                                         
쳐컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿐NTRY:            D7.L     should be 0 for reliability                        
                  A1.L     relative pointer to top of maths stack             
                                                                              
쿐XIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          
                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       
                                                                              
쿐RRORS:           ERR.OV   arithmetic overflow                                
읕컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴켸

   On entry the maths stack should contain two floating point numbers as shown
   below:-

        쳐컴컴컴컴컴컴캑
         multiplicand  NOS
        쳐컴컴컴컴컴컴캑
          multiplier   TOS
   A1 ->쳐컴컴컴컴컴컴캑

   where the multiplicand is the number being multiplied and the multiplier is
   what it is being multiplied by. The product is left on the top of the stack.

4966 RI_MULT       MOVEM.L  D4-6,-(A7)             ;save the remaining registers
                   SF       D5
                   SF       D6
                   MOVE.L   FP.MNTSA(A6,A1.L),D3
                   BGE.S    L0497C
                   JSR      RI_NEG(PC)
                   MOVE.L   D1,D3
                   ST       D6
497C L0497C        ADDQ.W   #FP.LENGTH,A1
                   MOVE.L   FP.MNTSA(A6,A1.L),D1
                   BGT.S    L0498C
                   BEQ.S    L049EA
                   JSR      RI_NEG(PC)
                   ST       D5
498C L0498C        LSL.L    #1,D1
                   MOVE.L   D1,D0
                   SWAP     D0
                   LSL.L    #1,D3
                   MOVE.L   D3,D2
                   SWAP     D2
                   MOVE.W   D3,D4
                   MULU     D1,D4
                   CLR.W    D4
                   SWAP     D4
                   MULU     D0,D3
                   MULU     D2,D1
                   ADD.L    D4,D3
                   ADD.L    D3,D1
                   MOVE.W   D1,D4
                   CLR.W    D1
                   SWAP     D1
                   ROXR.W   #1,D1
                   ROXL.L   #1,D1
                   MULU     D0,D2
                   MOVE.W   FP.EXPNT(A6,A1.L),D0
                   ADD.W    -FP.LENGTH+FP.EXPNT(6,A1.L),D0
                   SUBI.W   #$0800,D0
                   BLT.S    L049CE
                   ADD.L    D2,D1
                   BMI.S    L049D4
                   BEQ.S    L049CE
                   ASL.L    #1,D4
                   SUBQ.W   #1,D0
                   BGE.S    L049D6
49CE L049CE        CLR.W    D0
                   CLR.L    D1
                   BRA.S    L049DA

49D4 L049D4        LSR.L    #1,D1
49D6 L049D6        MOVEQ    #0,D4
                   ADDX.L   D4D1
49DA L049DA        MOVE.L   D1,FP.MNTSA(A6,A1.L)
                   MOVE.W   D0,FP.EXPNT(A6,A1.L)
                   CMP.B    D5,D6
                   BEQ.S    L049EA
                   JSR      RI_NEG(PC)
49EA L049EA        MOVEM.L  (A7)+,D4-6
                   BTST     #4,FP.EXPNT(A6,A1.L)
                   BNE.S    ERR_OV_4
                   MOVEQ    #0,D0                  ;signal "no errors"
                   RTS

49FA ERR_OV_4      MOVEQ    #ERR_OV,D0             ;signal "arithmetic overflow"
                   RTS

旼컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴커
=RI_DIV           DIVIDE NOS BY TOS                                           
쳐컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿐NTRY:            D7.L     should be 0 for reliability                        
                  A1.L     relative pointer to top of maths stack             
                                                                              
쿐XIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          
                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       
                                                                              
쿐RRORS:           ERR.OV   arithmetic overflow                                
읕컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴켸

   On entry the maths stack should contain two floating point numbers as shown
   below:-

        쳐컴컴컴컴컴컴캑
           dividend    NOS
        쳐컴컴컴컴컴컴캑
           divisor     TOS
   A1 ->쳐컴컴컴컴컴컴캑

   where the dividend is the number being divided and the divisor is what it is
   being divided by. The quotient is left on the top of the stack.

49FE RI_DIV        MOVEM.L  D4-5,-(A7)             ;save the remaining registers
                   SF       D5
                   MOVE.L   FP.MNTSA(A6,A1.L),D2
                   BGT.S    L04A14
                   BEQ.S    L04A84
                   JSR      RI_NEG(PC)
                   MOVE.L   D1,D2
                   ST       D5
4A14 L04A14        ADDQ.W   #FP.LENGTH,A1
                   MOVE.L   FP.MNTSA(A6,A1.L),D1
                   BGT.S    L04A24
                   BEQ.S    L04A7C
                   JSR      RI_NEG(PC)
                   NOT.B    D5
4A24 L04A24        MOVE.W   FP.EXPNT(A6,A1.L),D0
                   ADDI.W   #$0800,D0
                   SUB.W    -FP.LENGTH+FP.EXPNT(6,A1.L),D0
                   BGE.S    L04A38
                   CLR.W    D0
                   CLR.L    D3
                   BRA.S    L04A6C

4A38 L04A38        BTST     #12,D0
                   BNE.S    ERR_OV_5
                   MOVEQ    #31,D4
                   MOVEQ    #0,D3
4A42 L04A42        SUB.L    D2,D1
                   BCS.S    L04A50
                   BSET     D4,D3
                   ADD.L    D1,D1
                   DBEQ     D4,L04A42
                   BRA.S    L04A58

4A50 L04A50        ADD.L    D2,D1
                   ADD.L    D1,D1
                   DBEQ     D4,L04A42
4A58 L04A58        TST.L    D3
                   BLT.S    L04A64
                   SUB.L    D1,D2
                   BHI.S    L04A6C
                   ADDQ.L   #1,D3
                   BVC.S    L04A6C
4A64 L04A64        ADDQ.W   #1,D0
                   LSR.L    #1,D3
                   MOVEQ    #0,D1
                   ADDX.L   D1,D3
4A6C L04A6C        MOVE.L   D3,FP.MNTSA(A6,A1.L)
                   MOVE.W   D0,FP.EXPNT(A6,A1.L)
                   TST.B    D5
                   BEQ.S    L04A7C
                   JSR      RI_NEG(PC)
4A7C L04A7C        MOVEQ    #0,D0                  ;signal "no errors"
4A7E L04A7E        MOVEM.L  (A7)+,D4-5
                   RTS

4A84 L04A84        ADDQ.W   #FP.LENGTH,A1
4A86 ERR_OV_5      MOVEQ    #ERR_OV,D0             ;signal "arithmetic overflow"
                   BRA.S    L04A7E

旼컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴커
=RI_ABS           TAKE ABSOLUTE VALUE OF TOS                                  
=RI_NEG           NEGATE TOS                                                  
쳐컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿐NTRY:            D7.L     should be 0 for reliability                        
                  A1.L     relative pointer to top of maths stack             
                                                                              
쿐XIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          
                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       
                                                                              
쿐RRORS:           ERR.OV   arithmetic overflow                                
읕컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴켸

4A8A RI_ABS        TST.B    FP.MNTSA(A6,A1.L)      ;mantissa positive or negative ?
                   BGE.S    L04ACA                 ;exit if already positive
4A90 RI_NEG        MOVE.L   FP.MNTSA(A6,A1.L),D1   ;get mantissa
                   NEG.L    D1                     ;and negate it
                   BVS.S    L04AB0                 ;jump forward if overflow occured
                   CMPI.L   #$C0000000,D1          ;sign bit and most significant bit the same ?
                   BNE.S    L04AC6                 ;exit if not as this is the natural state
                   LSL.L    #1,D1                  ;otherwise make them the same
                   SUBQ.W   #1,FP.EXPNT(A6,A1.L)   ;and decrement exponent accordingly
                   BGE.S    L04AC6                 ;exit if exponent ok
                   ASR.L    #1,D1                  ;otherwise reset mantissa
                   CLR.W    FP.EXPNT(A6,A1.L)      ;and clear exponent
                   BRA.S    L04AC6

4AB0 L04AB0        LSR.L    #1,D1                  ;move mantissa up one to ensure bits different
                   ADDQ.W   #1,FP.EXPNT(A6,A1.L)   ;and increment exponent accordingly
                   BTST     #4,FP.EXPNT(A6,A1.L)   ;overflow of exponent ?
                   BEQ.S    L04AC6                 ;exit if not
                   SUBQ.W   #1,FP.EXPNT(A6,A1.L)   ;otherwise restore exponent
                   MOVEQ    #-1,D1                 ;and set mantissa to -1
                   LSR.L    #1,D1                  ;and then +1 with carry taken into account
4AC6 L04AC6        MOVE.L   D1,FP.MNTSA(A6,A1.L)   ;update mantissa
4ACA L04ACA        MOVEQ    #0,D0                  ;signal "no errors"
                   RTS

旼컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴커
=RI_DUP           DUPLICATE TOS                                               
쳐컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿐NTRY:            D7.L     should be 0 for reliability                        
                  A1.L     relative pointer to top of maths stack             
                                                                              
쿐XIT:             D0,D1,D2,D3,A0,A2 and A3 corrupted                          
                  D4,D5,D6,D7,A1,A4,A5 and A6 preserved                       
                                                                              
쿐RRORS:           ERR.OV   arithmetic overflow                                
읕컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴켸

4ACE RI_DUP        SUBQ.W   #FP.LENGTH,A1          ;make room on the maths stack for one number

   Copy the exponent and the mantissa from the old TOS to the new TOS.

4AD0 L04AD0        MOVE.W   FP.LENGTH+FP.EXPNT(A6,A1.L),FP.EXPNT(A6,A1.L)
                   MOVE.L   FP.LENGTH+FP.MNTSA(A6,A1.L),FP.MNTSA(A6,A1.L)
                   MOVEQ    #0,D0                  ;signal "no errors"
                   RTS

4AE0 L04AE0        MOVE.W   FP.EXPNT(A6,A1.L),D2
                   MOVE.L   FP.MNTSA(A6,A1.L),D1
                   JSR      L04AD0(PC)
                   MOVE.W   D2,FP.LENGTH+FP.EXPNT(A6,A1.L)
                   MOVE.L   D1,FP.LENGTH+FP.MNTSA(A6,A1.L)
                   MOVEQ    #0,D0                  ;signal "no errors"
                   RTS

